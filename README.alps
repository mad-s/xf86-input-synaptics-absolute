It is possible to use this driver with an ALPS Glidepoint device. If
you use a 2.6 linux kernel, you need to apply the ALPS kernel patch 
in the alps.patch file.

Since ALPS touchpads don't have the same resolution as Synaptics
touchpads, you probably have to change some parameter values. Here is
an example InputDevice section for the X configuration file.

Section "InputDevice"
  Driver  	"synaptics"
  Identifier  	"Mouse[1]"
  Option	"Device"  		"/dev/psaux"
  Option	"Protocol"		"auto-dev"
  Option	"LeftEdge"		"120"
  Option	"RightEdge"		"830"
  Option	"TopEdge"		"120"
  Option	"BottomEdge"		"650"
  Option	"FingerLow"		"14"
  Option	"FingerHigh"		"15"
  Option	"MaxTapTime"		"180"
  Option	"MaxTapMove"		"110"
  Option	"EmulateMidButtonTime"	"75"
  Option	"VertScrollDelta"	"20"
  Option	"HorizScrollDelta"	"20"
  Option	"MinSpeed"		"0.2"
  Option	"MaxSpeed"		"0.5"
  Option	"AccelFactor"		"0.01"
  Option	"EdgeMotionMinSpeed"	"15"
  Option	"EdgeMotionMaxSpeed"	"15"
  Option	"UpDownScrolling"	"1"
  Option	"CircularScrolling"	"1"
  Option	"CircScrollDelta"	"0.1"
  Option	"CircScrollTrigger"	"2"
EndSection

If you use a 2.4 linux kernel, you don't need to patch the kernel, but
you should instead set "Device" and "Protocol" like this:

  Option	"Protocol"		"alps"


On some (all?) ALPS hardware, it is not possible to disable tapping
unless you apply the patch below. However, some users have reported
that this patch breaks tap-and-drag operations, which is why the patch
is not included in the main alps.patch file.

--- linux/drivers/input/mouse/alps.c~alps-test3	2004-02-28 20:46:34.000000000 +0100
+++ linux-petero/drivers/input/mouse/alps.c	2004-02-28 20:49:12.000000000 +0100
@@ -87,6 +87,10 @@ static void ALPS_process_packet(struct p
 	y = (packet[4] & 0x7f) | ((packet[3] & 0x70)<<(7-4));
 	z = packet[5];
 
+	if (packet[2] & 1) {
+		z = 35;
+	}
+
 	if (z > 0) {
 		input_report_abs(dev, ABS_X, x);
 		input_report_abs(dev, ABS_Y, y);
@@ -97,7 +101,6 @@ static void ALPS_process_packet(struct p
 	if (z > 30) input_report_key(dev, BTN_TOUCH, 1);
 	if (z < 25) input_report_key(dev, BTN_TOUCH, 0);
 
-	left  |= (packet[2]     ) & 1;
 	left  |= (packet[3]     ) & 1;
 	right |= (packet[3] >> 1) & 1;
 	if (packet[0] == 0xff) {
